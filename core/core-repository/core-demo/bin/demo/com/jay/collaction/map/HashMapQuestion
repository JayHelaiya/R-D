	
1) what is HashCode ?

	 hashcode is unique number is generated by JVM which is nothing but hascode 
		
		- hasecode does not address of object
		- jvm use hashcode while saving object in hashing related data structure like hashtable,hashmap
		
		- the main advantage of saving object based on hashcode is search operation will be easy 
		- most powefull algoretheme is hashing .
		
		- hasecode generate based some algorethem with address of object it does not means address of the object
		- based on our requiremnt can generate out own hasecode 
		
		- proper way 
			
			- class Student {
			
					public int hasecode(){
						return roll;
					}
			
			}
			
			
			return roll no so unique  
		
		
		- improper way 
		
		
			class Student {
			
					public int hasecode(){
						return 100;
					}
			
			}
			
			[] [000000]	[]
			10	 100	01
			
			because for all student we are generating same hascode 
			
			
			
3)  hashcode and unique of contract		

4) 	how hashCode is work internally ?

	

	- hashMap use Node internally which represent doubly linkedList used to store the value 
	
	
		static class Node<K,V> implements Map.Entry<K,V> {
	        final int hash;
	        final K key;
	        V value;
	        Node<K,V> next;
	
	        Node(int hash, K key, V value, Node<K,V> next) {
	            this.hash = hash;
	            this.key = key;
	            this.value = value;
	            this.next = next;
	        }

	- so each index in array can imagine as node and each node can imagine linkedList
	
		- put method compute hase of key
		
		- hasecode compute same index known as hashcoligin
		
		- initial capacity is 16  
		
							
	score.put("Jone",99);
	score.put("clark",90);
	score.put("clak",90);
	score.put("jiya",100);
	score.put("mira",20);
	score.put("ark",10);
	
	
	put(K k,V v){
		
		hash(k)
		
		index= hash & (n-1)
	
	}
													[0] --> [Jone|582944|99|null]
													[1]
													[2] --> [clark|8282944|90|null]
													[3]
													[4] --> [clak|8282944|90|next] --> [jiya|8944|100|next] --> [mira|8282944|20|null] [hashcoligine]
													[5]
													[6]
													[7]
													[8]
													[9]
													[10] ---> [ark|8282944|10|null]
													[11]
													[12]
													[13]
													[14]
													[15]
													[16]
							

	
	
	
	 new HashMap<>()
	 new HashMap<>(initialCapacity)
	 new HashMap<>(initialCapacity, loadFactor)	
	 
7) contract
	
	1) if two object are equal then they must have the same hasCode.
	2) if two object has same haseCode , they may or may not be equal.
		 
	 
	 
6) Why do I need to override the equals and hashCode methods in Java?

	- https://stackoverflow.com/questions/2265503/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java
	
	You must override hashCode() in every class that overrides equals(). Failure to do so will result in a violation of the general contract for Object.hashCode(), which will prevent your class from functioning properly in conjunction with all hash-based collections, including HashMap, HashSet, and Hashtable.

	Let's try to understand it with an example of what would happen if we override equals() without overriding hashCode() and attempt to use a Map.

	Say we have a class like this and that two objects of MyClass are equal if their importantField is equal (with hashCode() and equals() generated by eclipse)

	- Override only equals

		If only equals is overriden, then when you call myMap.put(first,someValue) first will hash to some bucket and when you call myMap.put(second,someOtherValue) it will hash to some other bucket (as they have a different hashCode). So, although they are equal, as they don't hash to the same bucket, the map can't realize it and both of them stay in the map.
		
		Although it is not necessary to override equals() if we override hashCode(), let's see what would happen in this particular case where we know that two objects of MyClass are equal if their importantField is equal but we do not override equals().

	- Override only hashCode

		Imagine you have this
		
		MyClass first = new MyClass("a","first");
		MyClass second = new MyClass("a","second");
		If you only override hashCode then when you call myMap.put(first,someValue) it takes first, calculates its hashCode and stores it in a given bucket. Then when you call myMap.put(second,someOtherValue) it should replace first with second as per the Map Documentation because they are equal (according to the business requirement).
		
			 